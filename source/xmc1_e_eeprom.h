/******************************************************************************
* File Name:   e_eeprom_xmc1.h
*
* Description: Header file for emulated EEPROM implementation in XMC1000 MCUs.
* It contains the necessary macro and structure definitions to use configure 
* flash memory as emulated EEPROM.
*
* Related Document: See README.md
*
******************************************************************************
*
* Copyright (c) 2015-2021, Infineon Technologies AG
* All rights reserved.                        
*                                             
* Boost Software License - Version 1.0 - August 17th, 2003
* 
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
* 
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
* 
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*
*****************************************************************************
* Change History
* --------------
*
* 2015-02-16:
*     - Initial version<br>
*
* 2015-04-24:
*     - E_EEPROM_XMC1_ReadBlockWithCRC API renamed to
*     E_EEPROM_XMC1_VerifyBlockCrcStatus<br>
*     - E_EEPROM_XMC1_OPERATION_STATUS_t enumeration parameter names
*     changed and additional status parameter
*       E_EEPROM_XMC1_OPERATION_STATUS_NO_CRC_WRITTEN added.
*
* 2016-07-08:
*     - Fixed incorrect case for an included header.
*
* 2021-01-08:
*     - Modified check for minimum XMCLib version
*****************************************************************************/

#ifndef E_EEPROM_XMC1_H
#define E_EEPROM_XMC1_H

/*****************************************************************************
 * HEADER FILES
 ****************************************************************************/

#include "xmc_flash.h"

//conf

/*
 *  Flash address and Size informations as per user configuration
 */
#define E_EEPROM_XMC1_FLASH_TOTAL_SIZE     (4096U)
#define E_EEPROM_XMC1_FLASH_BANK_SIZE      (2048U)

/*
 *  EMULATED_EEPROM Bank, start and end addresses
 */
#define E_EEPROM_XMC1_FLASH_BANK0_BASE     (0x10032000U)
#define E_EEPROM_XMC1_FLASH_BANK0_END      (0x100327ffU)
#define E_EEPROM_XMC1_FLASH_BANK1_BASE     (0x10032800U)
#define E_EEPROM_XMC1_FLASH_BANK1_END      (0x10032fffU)

/* Total number of configured Data blocks */
#define E_EEPROM_XMC1_MAX_BLOCK_COUNT      (1U)
/*
 *  Total number of pages per bank, resulting after division of banks
 *  i.e. E_EEPROM_XMC1_BANK_PAGES = (E_EEPROM_XMC1_FLASH_TOTAL_SIZE in Bytes / ((256 Bytes * 2 Banks))
 */
#define E_EEPROM_XMC1_BANK_PAGES           (8U)

//conf end

#ifdef E_EEPROM_XMC1_CRC_SW_ENABLED
#include "CRC_SW/crc_sw.h"
#endif

/*****************************************************************************
 * MACROS
 ****************************************************************************/
#define E_EEPROM_XMC1_XMC_LIB_MAJOR_VERSION 2
#define E_EEPROM_XMC1_XMC_LIB_MINOR_VERSION 0
#define E_EEPROM_XMC1_XMC_LIB_PATCH_VERSION 0

#if !((XMC_LIB_MAJOR_VERSION > E_EEPROM_XMC1_XMC_LIB_MAJOR_VERSION) ||\
      ((XMC_LIB_MAJOR_VERSION == E_EEPROM_XMC1_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION > E_EEPROM_XMC1_XMC_LIB_MINOR_VERSION)) ||\
      ((XMC_LIB_MAJOR_VERSION == E_EEPROM_XMC1_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION == E_EEPROM_XMC1_XMC_LIB_MINOR_VERSION) && (XMC_LIB_PATCH_VERSION >= E_EEPROM_XMC1_XMC_LIB_PATCH_VERSION)))
#error "E_EEPROM_XMC1 requires XMC Peripheral Library v2.0.0 or higher"
#endif

/** Physical flash Block size and Page size defined*/
#define E_EEPROM_XMC1_FLASH_BLOCK_SIZE  (16U)
#define E_EEPROM_XMC1_FLASH_PAGE_SIZE   (256U)

/*
 *  These are global variables used only for internal testing purpose.
 *  Application code shall not use these variables by enabling E_EEPROM_XMC1_TEST_HOOK_ENABLE macro definition.
 */
#ifdef E_EEPROM_XMC1_TEST_HOOK_ENABLE
uint32_t e_eeprom_xmc1_test_hook_readblock;
uint32_t e_eeprom_xmc1_test_hook_writeblock;
uint32_t e_eeprom_xmc1_test_hook_writepage;
uint32_t e_eeprom_xmc1_test_hook_erasepage;
uint32_t e_eeprom_xmc1_test_hook_readword;
uint32_t e_eeprom_xmc1_test_hook_getflashstatus;
#endif

/*****************************************************************************
* ENUMS
*****************************************************************************/
/** Defines the error codes for E_EEPROM_XMC1 APP. */
typedef enum E_EEPROM_XMC1_STATUS
{
  E_EEPROM_XMC1_STATUS_SUCCESS        = 0U, /**< Successful completion of APP initialization */
  E_EEPROM_XMC1_STATUS_FAILURE        = 1U, /**< Initialization failed due to internal operational error*/
  E_EEPROM_XMC1_STATUS_UNINITIALIZED  = 2U, /**< APP is in Uninitialized state*/
  E_EEPROM_XMC1_STATUS_IDLE           = 3U, /**< APP is in IDLE state. Only used in E_EEPROM_XMC1_GetStatus() API */
  E_EEPROM_XMC1_STATUS_BUSY           = 4U  /**< APP is in BUSY state. Only used in E_EEPROM_XMC1_GetStatus() API */
} E_EEPROM_XMC1_STATUS_t;

/**
 * Defines current status for E_EEPROM_XMC1 APP. */
typedef enum E_EEPROM_XMC1_OPERATION_STATUS
{
  E_EEPROM_XMC1_OPERATION_STATUS_SUCCESS            = 0U, /**< Successful completion of operation*/
  E_EEPROM_XMC1_OPERATION_STATUS_FAILURE            = 1U, /**< APP failed due to internal flash operational errors*/
  E_EEPROM_XMC1_OPERATION_STATUS_INCONSISTENT_BLOCK = 2U, /**< Targeted block is inconsistent*/
  E_EEPROM_XMC1_OPERATION_STATUS_INVALID_BLOCK      = 3U, /**< The latest copy of the targeted block was invalidated */
  E_EEPROM_XMC1_OPERATION_STATUS_CRC_FAILED         = 4U, /**< CRC verification failed for the targeted block*/
  E_EEPROM_XMC1_OPERATION_STATUS_NOT_ALLOWED        = 5U, /**< Operation not allowed to continue*/
  E_EEPROM_XMC1_OPERATION_STATUS_MEMORY_BANK_FULL   = 6U, /**< Write/Invalidate operation failed when bank has no space.
                                                             Call E_EEPROM_XMC1_StartGarbageCollection API to proceed */
  E_EEPROM_XMC1_OPERATION_STATUS_NO_CRC_WRITTEN     = 7U  /**< Written block does not have CRC checksum enabled.*/
} E_EEPROM_XMC1_OPERATION_STATUS_t;

/*****************************************************************************
 * * DATA STRUCTURES
*****************************************************************************/

/**  Data structure to configure the Data Block parameters */
typedef struct E_EEPROM_XMC1_BLOCK
{
  uint8_t block_number; /**< Logical block number (Block ID) */

  uint32_t size; /**< Size of the logical block */

} E_EEPROM_XMC1_BLOCK_t;


/** Data structure to hold the header information about a particular user data block */
typedef struct E_EEPROM_XMC1_BLOCK_HEADER
{
  uint8_t block_number; /**< User data block number */

  uint8_t status; /**< User data block status */

} E_EEPROM_XMC1_BLOCK_HEADER_t;


/*lint -e46 */
/** Bit field data structure holds the overall information about a particular user data block */
typedef struct E_EEPROM_XMC1_CACHE_STATUS
{
  uint32_t valid      : 1; /**< Indicates the data block stored in the flash is valid or invalid */

  uint32_t consistent : 1; /**< Indicates the data block stored in the flash is faulty or not */

  uint32_t copied     : 1; /**< Indicates the data blocks are copied or not to free bank during GC */

  uint32_t crc        : 1; /**< Indicates if the block is enabled with a valid 16 bit CRC */

  uint32_t unused     : 28; /* unused */

} E_EEPROM_XMC1_CACHE_STATUS_t;
/*lint -e46 */


/** Data structure to hold the information about the physical address and status of a user data block */
typedef struct E_EEPROM_XMC1_CACHE
{
  uint32_t address; /**< It has the actual physical address of the flash where the written data block starts */

  E_EEPROM_XMC1_CACHE_STATUS_t status; /**< Status information of the written user data block (Valid/Consistent/CRC)*/

} E_EEPROM_XMC1_CACHE_t;


/** Data structure to hold the count of flash physical blocks and status of a user data block */
typedef struct E_EEPROM_XMC1_TRAVERSE_BLOCK_RESULT
{
  uint32_t block_count; /**< Number of physical flash blocks required for a particular data block */

  E_EEPROM_XMC1_CACHE_STATUS_t status; /**< status of the user data block */

} E_EEPROM_XMC1_TRAVERSE_BLOCK_RESULT_t;


/** Data structure to hold the complete state data information of Emulation APP (Run Time Handler)*/
typedef struct E_EEPROM_XMC1_DATA
{
  E_EEPROM_XMC1_CACHE_t *block_info;/**< User data block informations are stored here*/

  E_EEPROM_XMC1_TRAVERSE_BLOCK_RESULT_t block_result; /**< get previous data block read result information*/

  uint32_t  current_bank;  /**< Stores the current Bank on which blocks write operation will be done */

  uint32_t  gc_dest_addr; /**< Destination address for copying data during GC */

  uint32_t  gc_src_addr; /**< Source address from which data needs to be copied during GC */

  uint32_t  curr_bank_end_addr; /**< Current bank end address */

  uint32_t  prev_bank_end_addr; /**< previous bank end address */

  uint32_t  next_free_block_addr; /**< Stores the next available flash address for next block write */

  uint32_t  curr_bank_src_addr; /**< Used for cache update and later stores the current Bank base address */

  uint32_t  gc_block_counter; /**< Tracks number of flash blocks read/written during GC process */

  uint32_t  written_block_counter; /**< Keeps track of the number of flash blocks written for an user data block */

  uint8_t   read_write_buffer[E_EEPROM_XMC1_FLASH_BLOCK_SIZE]; /**< Internal buffer to load and store single block */

  uint32_t  crc_buffer; /**< Keeps track the CRC 16 bit CRC value */

  uint8_t   page_write_buffer[E_EEPROM_XMC1_FLASH_PAGE_SIZE]; /**< Internal buffer to load and store single page */

  uint32_t  user_write_bytes_count; /**< Keeps track of the number of bytes written */

  uint32_t  gc_state; /**< State variable to keep track of the current state of the garbage collection procedure */

  uint32_t  init_gc_state; /**< Stores the current state for initialization process */

  uint32_t  gc_log_block_count; /**< Tracks the number of logical blocks covered during GC process  */

  uint32_t  cache_state; /**< Stores current state of the cache update process */

  uint32_t  updated_cache_index; /**< Keeps track of the current block for which cache update is ongoing */

  uint32_t  user_write_state; /**< Current status of the user write */

  uint32_t  read_start_address; /**< Current flash starting address to read the data */

} E_EEPROM_XMC1_DATA_t;


/** Data structure to configure the APP properties. Use @ref E_EEPROM_XMC1_t type for accessing the members */
typedef struct E_EEPROM_XMC1
{
  E_EEPROM_XMC1_BLOCK_t *block_config_ptr; /**< Pointer to user block configurations */

  E_EEPROM_XMC1_DATA_t *data_ptr; /**< Pointer to the state variable data structure */

  #ifdef E_EEPROM_XMC1_CRC_SW_ENABLED
  CRC_SW_t* const crc_handle_ptr;  /**< CRC APP handle pointer*/
  #endif

  E_EEPROM_XMC1_STATUS_t  state; /**< Current state of the APP instance*/

  const uint8_t  block_count; /**< Number of configured user data blocks */

  const uint8_t  erase_all_auto_recovery; /**< Erase Complete emulation area and recover to default state */

  const uint8_t  data_block_crc; /**< Allow to calculate CRC for each data block on write */

  const uint8_t  garbage_collection; /**< Enables garbage collection when no space available for new write*/

} E_EEPROM_XMC1_t;

typedef E_EEPROM_XMC1_t* E_EEPROM_XMC1_HANDLE_PTR_t; /**< Defines a pointer to APP Handle*/

/**
 *@}
 */
 
#ifdef __cplusplus
extern "C"  {
#endif

/*****************************************************************************
 * API Prototypes
 ****************************************************************************/
 E_EEPROM_XMC1_STATUS_t E_EEPROM_XMC1_Init(E_EEPROM_XMC1_t *const handle_ptr);

 E_EEPROM_XMC1_OPERATION_STATUS_t E_EEPROM_XMC1_Write(uint8_t block_number, uint8_t *data_buffer_ptr);
 
 E_EEPROM_XMC1_OPERATION_STATUS_t E_EEPROM_XMC1_Read(uint8_t block_number,
                                                    uint32_t block_offset,
                                                    uint8_t *data_buffer_ptr,
                                                    uint32_t length );
 E_EEPROM_XMC1_OPERATION_STATUS_t E_EEPROM_XMC1_StartGarbageCollection(void);
 
 E_EEPROM_XMC1_OPERATION_STATUS_t E_EEPROM_XMC1_InvalidateBlock(uint8_t block_number);

 E_EEPROM_XMC1_STATUS_t E_EEPROM_XMC1_GetStatus(void);

 bool E_EEPROM_XMC1_IsGarbageCollectionNeeded(uint8_t block_number);

#ifdef E_EEPROM_XMC1_CRC_SW_ENABLED
 E_EEPROM_XMC1_OPERATION_STATUS_t E_EEPROM_XMC1_VerifyBlockCrcStatus(uint8_t block_number, uint8_t *data_buffer_ptr);
#endif

 E_EEPROM_XMC1_OPERATION_STATUS_t E_EEPROM_XMC1_GetPreviousData(uint8_t block_number,
                                                               uint32_t block_offset,
                                                               uint8_t *data_buffer_ptr,
                                                               uint32_t length );

#ifdef __cplusplus
}
#endif


#endif /* E_EEPROM_XMC1_H_ */
