/******************************************************************************
* File Name:   xmc1_e_eeprom_example.c
*
* Description: This Source file implements the example application to use 
* APIs in e_eeprom_xmc1.c file function for XMC1000 MCU. 
*
* Related Document: See README.md
*
******************************************************************************
*
* Copyright (c) 2015-2021, Infineon Technologies AG
* All rights reserved.                        
*                                             
* Boost Software License - Version 1.0 - August 17th, 2003
* 
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
* 
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
* 
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*                                                                              
*****************************************************************************/
#include "xmc_device.h"
#if (UC_FAMILY == XMC1)
//#if defined(TARGET_KIT_XMC11_BOOT_001) || defined(TARGET_KIT_XMC12_BOOT_001) || defined(TARGET_KIT_XMC13_BOOT_001) || defined(TARGET_KIT_XMC14_BOOT_001)
/*****************************************************************************
 * HEADER FILES
 ****************************************************************************/
#include "xmc1_e_eeprom.h"
#include "xmc1_e_eeprom_example.h"
#include "print_functions.h"

/*****************************************************************************
 * MACROS
 ****************************************************************************/
#define E_EEPROM_BLOCK_NUM     1U
#define E_EEPROM_BLOCK1_SIZE   64U
/* Macros for the messages to print */
#define E_EEPROM_EXISTING_DATA_STRING          "Existing data in EEPROM\r\n"
#define E_EEPROM_NEW_DATA_STRING               "New data in EEPROM\r\n"
#define E_EEPROM_INIT_ERROR_STRING             "EEPROM initialization failed\r\n"
#define E_EEPROM_READ_ERROR_STRING             "Failed to read data from EEPROM\r\n"
#define E_EEPROM_WRITE_ERROR_STRING            "Failed to write data to EEPROM\r\n"
#define E_EEPROM_INCONSISTENT_BLOCK_STRING     "E_EEPROM block is inconsistent, writing sample data (0x00)\r\n"

/*****************************************************************************
 * GLOBAL DATA
 ****************************************************************************/
/* Variable to flag if E_EEPROM block is inconsistent */
uint8_t E_EEPROM_inconsistent = 0U; /* 0U = Inconsistent, 1U = Consistent */
/* Structure to store user data block informations */
E_EEPROM_XMC1_CACHE_t block_info_buf[E_EEPROM_BLOCK_NUM];
E_EEPROM_XMC1_DATA_t  E_EEPROM_XMC1_config =
{
        .block_info = block_info_buf
};
/**
 *  User defined Data Block configurations
 */
const E_EEPROM_XMC1_BLOCK_t E_EEPROM_XMC1_block_Config[] =
{
    /* Block 1 Configuration */
    {1U, E_EEPROM_BLOCK1_SIZE}
};

/*
*  EMULATED_EEPROM handle structure definition
*/
E_EEPROM_XMC1_t E_EEPROM_XMC1_handle =
{
 .block_config_ptr        = (E_EEPROM_XMC1_BLOCK_t *)(void*)E_EEPROM_XMC1_block_Config, /* Pointer to user block configurations */
 .data_ptr                = &E_EEPROM_XMC1_config,                                      /* Pointer to the state variable data structure */
#ifdef E_EEPROM_XMC1_CRC_SW_ENABLED
 .crc_handle_ptr          = null
#endif
 .state                   = E_EEPROM_XMC1_STATUS_UNINITIALIZED,  /* Current state of EEPROM */
 .block_count             = E_EEPROM_BLOCK_NUM,                  /* Number of EEPROM blocks to be configured */
 .erase_all_auto_recovery = 0U,                                  /* Erase Complete emulation area and recover to default state disabled */
 .data_block_crc          = 0U,                                  /* Data block CRC disabled */
 .garbage_collection      = 1U                                   /* Garbage collection enabled */
};

/*****************************************************************************
 * LOCAL FUNCTION PROTOTYPES
 ****************************************************************************/
static void prep_write_buffer(uint8_t *rbuf, uint8_t *wbuf, uint32_t len);
static void E_EEPROM_test(uint8_t blockNum, uint32_t block_size);

/*******************************************************************************
* Function Name: prep_write_buffer
********************************************************************************
* Summary:
* This function increments each element of read buffer and stores the new value
* in write buffer. It is done to update the contents in the flash.
*
* Parameters:
* rbuf - read buffer
* wbuf - write buffer
* len - lenght of buffers
*
* Return:
* void
*
*******************************************************************************/
static void prep_write_buffer(uint8_t *rbuf, uint8_t *wbuf, uint32_t len)
{
    uint32_t i;
    for(i = 0; i < len; i++)
    {
        wbuf[i] = rbuf[i] + 1;
    }
}

/*******************************************************************************
* Function Name: E_EEPROM_test
********************************************************************************
* Summary:
* This is the example function to test e_eeprom in XMC1000. It performs below 
* steps.
* 1 - Read data from an eeprom block
* 2 - increment the read data by 1 and program it back to eeprom
* 3 - Read and print new data from eeprom
*
* Parameters:
* blockNum - EEPROM Block number to test
* block_size - Size of the EEPROM block
*
* Return:
* E_EEPROM_XMC1_STATUS_t
*
*******************************************************************************/
static void E_EEPROM_test(uint8_t blockNum, uint32_t block_size)
{
    uint8_t data_wbuffer[block_size];
    uint8_t data_rbuffer[block_size];

    /* Write data if EEPROM is inconsistent */
    if(E_EEPROM_inconsistent != 1U)
    {
        print_buffer_text((uint8_t *)E_EEPROM_INCONSISTENT_BLOCK_STRING, sizeof(E_EEPROM_INCONSISTENT_BLOCK_STRING));
        memset(data_wbuffer, 0x00, block_size);
        if(E_EEPROM_XMC1_Write(blockNum, data_wbuffer) != E_EEPROM_XMC1_OPERATION_STATUS_SUCCESS)
        {
            /* Failed to write data to emulated EEPROM */
            print_buffer_text((uint8_t *)E_EEPROM_WRITE_ERROR_STRING, sizeof(E_EEPROM_WRITE_ERROR_STRING));
            return;
        }
    }

    /* Read and print existing data from emulated EEPROM */
    if(E_EEPROM_XMC1_Read(blockNum, 0U, data_rbuffer, block_size) != E_EEPROM_XMC1_OPERATION_STATUS_SUCCESS)
    {
        /* Failed to read data from emulated EEPORM */
        print_buffer_text((uint8_t *)E_EEPROM_READ_ERROR_STRING, sizeof(E_EEPROM_READ_ERROR_STRING));
        return;
    }
    print_buffer_text((uint8_t *)E_EEPROM_EXISTING_DATA_STRING, sizeof(E_EEPROM_EXISTING_DATA_STRING));
    print_buffer_hex(data_rbuffer, block_size);

    /* Write new data to emulated EEPROM */
    prep_write_buffer(data_rbuffer, data_wbuffer, block_size);
    if(E_EEPROM_XMC1_Write(blockNum, data_wbuffer) != E_EEPROM_XMC1_OPERATION_STATUS_SUCCESS)
    {
        /* Failed to write data to emulated EEPROM */
        print_buffer_text((uint8_t *)E_EEPROM_WRITE_ERROR_STRING, sizeof(E_EEPROM_WRITE_ERROR_STRING));
        return;
    }

    /* Read and print new data from emulated EEPROM */
    if(E_EEPROM_XMC1_Read(blockNum, 0U, data_rbuffer, block_size) != E_EEPROM_XMC1_OPERATION_STATUS_SUCCESS)
    {
        /* Failed to read data from emulated EEPORM */
        print_buffer_text((uint8_t *)E_EEPROM_READ_ERROR_STRING, sizeof(E_EEPROM_READ_ERROR_STRING));
        return;
    }
    print_buffer_text((uint8_t *)E_EEPROM_NEW_DATA_STRING, sizeof(E_EEPROM_NEW_DATA_STRING));
    print_buffer_hex(data_rbuffer, block_size);

}

/*******************************************************************************
* Function Name: E_EEPROM_erase
********************************************************************************
* Summary:
* Function to erase the EEPROM area.
*
* Parameters:
* void
*
* Return:
* void
*
*******************************************************************************/
void E_EEPROM_erase()
{
    XMC_FLASH_ErasePages( (uint32_t*)E_EEPROM_XMC1_FLASH_BANK0_BASE, (E_EEPROM_XMC1_BANK_PAGES*1));
    XMC_FLASH_ErasePages( (uint32_t*)E_EEPROM_XMC1_FLASH_BANK1_BASE, (E_EEPROM_XMC1_BANK_PAGES*1));
}

/*******************************************************************************
* Function Name: E_EEPROM_example
********************************************************************************
* Summary:
* Function to initialize eeprom and execute the tests.
*
* Parameters:
* void
*
* Return:
* void
*
*******************************************************************************/
void E_EEPROM_example()
{
    uint8_t i;

    /* Before starting, make sure that the flash shall not contain any data in the EEPROM area. Else erase the EEPROM
     * area using xmc1_flash LLD API XMC_FLASH_ErasePages() API shown below. Enable the below commented code and build.
     * Once the example runs successfully, this line can be removed from future builds to ensure data retention. */
//    XMC_FLASH_ErasePages( (uint32_t*)E_EEPROM_XMC1_FLASH_BANK0_BASE, (E_EEPROM_XMC1_BANK_PAGES*1));
//    XMC_FLASH_ErasePages( (uint32_t*)E_EEPROM_XMC1_FLASH_BANK1_BASE, (E_EEPROM_XMC1_BANK_PAGES*1));

    /* Initialize emulated EEPROM */
    if(E_EEPROM_XMC1_Init(&E_EEPROM_XMC1_handle) != E_EEPROM_XMC1_STATUS_SUCCESS)
    {
        /* Emulated EEPROM initialization failed */
        print_buffer_text((uint8_t *)E_EEPROM_INIT_ERROR_STRING, sizeof(E_EEPROM_INIT_ERROR_STRING));
        return;
    }

    for(i = 1; i <= E_EEPROM_XMC1_handle.block_count; i++)
    {
        /* Update if the block is consistent or not */
        E_EEPROM_inconsistent = E_EEPROM_XMC1_handle.data_ptr->block_info[i-1].status.consistent;
        E_EEPROM_test(i, E_EEPROM_XMC1_handle.block_config_ptr[i-1].size);
    }
}
#endif
